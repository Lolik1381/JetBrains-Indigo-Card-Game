type: edu
files:
- name: src/indigo/Main.kt
  visible: true
  text: |-
    package indigo

    fun main() {
        println("Hello World!")
    }
  learner_created: false
- name: test/IndigoCardGameTest.kt
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testing.TestedProgram

    class ErrorData(val correct: Boolean, val errorMsg: String,
                    val topCard: String = "", val cardsList: List<String> = emptyList())

    class CardGameTest : StageTest<Any>() {

        @DynamicTest
        fun playFirstNormalExeTest3(): CheckResult {
            val deck = mutableListOf<String>()
            val cardsInHand = mutableListOf<String>()
            var pointsPlayer = 0
            var pointsComputer = 0
            var pointsOnTable = 0
            var numOfCardsPlayer = 0
            var numOfCardsComputer = 0
            var numOfCardsOnTable = 0
            var whoWon = 0

            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("yes").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            deck.addAll(validOutput.cardsList)
            var topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            numOfCardsOnTable = 4
            pointsOnTable = countPoints(validOutput.cardsList)
            repeat(4) {
                for (numOfCards in 6 downTo 1) {
                    validOutput = checkPlayerOutput2(outputString, numOfCards, numOfCardsOnTable, topCard)
                    if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    if (numOfCards == 6) {
                        cardsInHand.clear()
                        cardsInHand.addAll(validOutput.cardsList)
                        for (card in cardsInHand)
                            if ( deck.contains(card) )
                                return CheckResult(false, "Some cards in hand have already passed on table (Duplicates).")
                        deck.addAll(cardsInHand)
                    } else {
                        if ( !cardsInHand.containsAll(validOutput.cardsList) )
                            return CheckResult(false, "Cards in hand have changed since the last card was played.")
                    }
                    var hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.cardsList.first())
                        a.first == b.first || a.second == b.second
                    }
                    topCard = validOutput.cardsList.first()
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    cardsInHand.remove(topCard)
                    outputString = main.execute("1").trim()
                    if (hasWon) {
                        whoWon = 0
                        pointsPlayer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsPlayer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Player wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong player wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }

                    validOutput = checkComputerOutput2(outputString, numOfCardsOnTable, topCard)
                    if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.topCard)
                        (a.first == b.first) || (a.second == b.second)
                    }
                    topCard = validOutput.topCard
                    if ( deck.contains(topCard) )
                        return CheckResult(false, "Computer played card is a duplicate.")
                    deck.add(topCard)
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    outputString = outputString.substringAfter(topCard).trim()
                    if (hasWon) {
                        whoWon = 1
                        pointsComputer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsComputer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Computer wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong computer wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }
                }
            }

            position = if (numOfCardsOnTable == 0) checkOutput(outputString.lowercase(), 0, "No cards on the table".lowercase())
            else checkOutput(outputString.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output for number of cards or the top card.")
            if (whoWon == 0) {
                pointsPlayer += pointsOnTable
                numOfCardsPlayer += numOfCardsOnTable
            } else {
                pointsComputer += pointsOnTable
                numOfCardsComputer += numOfCardsOnTable
            }
            if (numOfCardsPlayer >= numOfCardsComputer) pointsPlayer += 3
            else pointsComputer += 3
            position = checkOutput(outputString.lowercase(), position,
                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase(),
                "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun playFirstNormalExeTest4(): CheckResult {
            val deck = mutableListOf<String>()
            val cardsInHand = mutableListOf<String>()
            var pointsPlayer = 0
            var pointsComputer = 0
            var pointsOnTable = 0
            var numOfCardsPlayer = 0
            var numOfCardsComputer = 0
            var numOfCardsOnTable = 0
            var whoWon = 0

            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("yes").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            deck.addAll(validOutput.cardsList)
            var topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            numOfCardsOnTable = 4
            pointsOnTable = countPoints(validOutput.cardsList)
            repeat(4) {
                for (numOfCards in 6 downTo 1) {
                    validOutput = checkPlayerOutput2(outputString, numOfCards, numOfCardsOnTable, topCard)
                    if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    if (numOfCards == 6) {
                        cardsInHand.clear()
                        cardsInHand.addAll(validOutput.cardsList)
                        for (card in cardsInHand)
                            if ( deck.contains(card) )
                                return CheckResult(false, "Some cards in hand have already passed on table (Duplicates).")
                        deck.addAll(cardsInHand)
                    } else {
                        if ( !cardsInHand.containsAll(validOutput.cardsList) )
                            return CheckResult(false, "Cards in hand have changed since the last card was played.")
                    }
                    var hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.cardsList.last())
                        a.first == b.first || a.second == b.second
                    }
                    topCard = validOutput.cardsList.last()
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    cardsInHand.remove(topCard)
                    outputString = main.execute("$numOfCards").trim()
                    if (hasWon) {
                        whoWon = 0
                        pointsPlayer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsPlayer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Player wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong player wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }

                    validOutput = checkComputerOutput2(outputString, numOfCardsOnTable, topCard)
                    if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.topCard)
                        (a.first == b.first) || (a.second == b.second)
                    }
                    topCard = validOutput.topCard
                    if ( deck.contains(topCard) )
                        return CheckResult(false, "Computer played card is a duplicate.")
                    deck.add(topCard)
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    outputString = outputString.substringAfter(topCard).trim()
                    if (hasWon) {
                        whoWon = 1
                        pointsComputer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsComputer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Computer wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong computer wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }
                }
            }

            position = if (numOfCardsOnTable == 0) checkOutput(outputString.lowercase(), 0, "No cards on the table".lowercase())
            else checkOutput(outputString.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output for number of cards or the top card.")
            if (whoWon == 0) {
                pointsPlayer += pointsOnTable
                numOfCardsPlayer += numOfCardsOnTable
            } else {
                pointsComputer += pointsOnTable
                numOfCardsComputer += numOfCardsOnTable
            }
            if (numOfCardsPlayer >= numOfCardsComputer) pointsPlayer += 3
            else pointsComputer += 3
            position = checkOutput(outputString.lowercase(), position,
                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase(),
                "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun playSecondNormalExeTest3(): CheckResult {
            val deck = mutableListOf<String>()
            val cardsInHand = mutableListOf<String>()
            var pointsPlayer = 0
            var pointsComputer = 0
            var pointsOnTable = 0
            var numOfCardsPlayer = 0
            var numOfCardsComputer = 0
            var numOfCardsOnTable = 0
            var whoWon = 0

            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("no").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            deck.addAll(validOutput.cardsList)
            var topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            numOfCardsOnTable = 4
            pointsOnTable = countPoints(validOutput.cardsList)
            repeat(4) {
                for (numOfCards in 6 downTo 1) {
                    validOutput = checkComputerOutput2(outputString, numOfCardsOnTable, topCard)
                    if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    var hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.topCard)
                        (a.first == b.first) || (a.second == b.second)
                    }
                    topCard = validOutput.topCard
                    if ( deck.contains(topCard) )
                        return CheckResult(false, "Computer played card is a duplicate.")
                    deck.add(topCard)
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    outputString = outputString.substringAfter(topCard).trim()
                    if (hasWon) {
                        whoWon = 1
                        pointsComputer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsComputer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Computer wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong computer wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }

                    validOutput = checkPlayerOutput2(outputString, numOfCards, numOfCardsOnTable, topCard)
                    if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    if (numOfCards == 6) {
                        cardsInHand.clear()
                        cardsInHand.addAll(validOutput.cardsList)
                        for (card in cardsInHand)
                            if ( deck.contains(card) )
                                return CheckResult(false, "Some cards in hand have already passed on table (Duplicates).")
                        deck.addAll(cardsInHand)
                    } else {
                        if ( !cardsInHand.containsAll(validOutput.cardsList) )
                            return CheckResult(false, "Cards in hand have changed since the last card was played.")
                    }
                    hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.cardsList.first())
                        a.first == b.first || a.second == b.second
                    }
                    topCard = validOutput.cardsList.first()
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    cardsInHand.remove(topCard)
                    outputString = main.execute("1").trim()
                    if (hasWon) {
                        whoWon = 0
                        pointsPlayer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsPlayer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Player wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong player wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }


                }
            }

            position = if (numOfCardsOnTable == 0) checkOutput(outputString.lowercase(), 0, "No cards on the table".lowercase())
            else checkOutput(outputString.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output for number of cards or the top card.")
            if (whoWon == 0) {
                pointsPlayer += pointsOnTable
                numOfCardsPlayer += numOfCardsOnTable
            } else {
                pointsComputer += pointsOnTable
                numOfCardsComputer += numOfCardsOnTable
            }
            if (numOfCardsPlayer > numOfCardsComputer) pointsPlayer += 3
            else pointsComputer += 3
            position = checkOutput(outputString.lowercase(), position,
                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase(),
                "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun playSecondNormalExeTest4(): CheckResult {
            val deck = mutableListOf<String>()
            val cardsInHand = mutableListOf<String>()
            var pointsPlayer = 0
            var pointsComputer = 0
            var pointsOnTable = 0
            var numOfCardsPlayer = 0
            var numOfCardsComputer = 0
            var numOfCardsOnTable = 0
            var whoWon = 0

            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("no").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            deck.addAll(validOutput.cardsList)
            var topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            numOfCardsOnTable = 4
            pointsOnTable = countPoints(validOutput.cardsList)
            repeat(4) {
                for (numOfCards in 6 downTo 1) {
                    validOutput = checkComputerOutput2(outputString, numOfCardsOnTable, topCard)
                    if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    var hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.topCard)
                        (a.first == b.first) || (a.second == b.second)
                    }
                    topCard = validOutput.topCard
                    if ( deck.contains(topCard) )
                        return CheckResult(false, "Computer played card is a duplicate.")
                    deck.add(topCard)
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    outputString = outputString.substringAfter(topCard).trim()
                    if (hasWon) {
                        whoWon = 1
                        pointsComputer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsComputer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Computer wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong computer wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }

                    validOutput = checkPlayerOutput2(outputString, numOfCards, numOfCardsOnTable, topCard)
                    if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                    if (numOfCards == 6) {
                        cardsInHand.clear()
                        cardsInHand.addAll(validOutput.cardsList)
                        for (card in cardsInHand)
                            if ( deck.contains(card) )
                                return CheckResult(false, "Some cards in hand have already passed on table (Duplicates).")
                        deck.addAll(cardsInHand)
                    } else {
                        if ( !cardsInHand.containsAll(validOutput.cardsList) )
                            return CheckResult(false, "Cards in hand have changed since the last card was played.")
                    }
                    hasWon = if (numOfCardsOnTable == 0) false
                    else {
                        val a = getRankSuit(topCard)
                        val b = getRankSuit(validOutput.cardsList.last())
                        a.first == b.first || a.second == b.second
                    }
                    topCard = validOutput.cardsList.last()
                    numOfCardsOnTable++
                    pointsOnTable += countPoints(listOf(topCard))
                    cardsInHand.remove(topCard)
                    outputString = main.execute("$numOfCards").trim()
                    if (hasWon) {
                        whoWon = 0
                        pointsPlayer += pointsOnTable
                        pointsOnTable = 0
                        numOfCardsPlayer += numOfCardsOnTable
                        numOfCardsOnTable = 0
                        position = checkOutput(outputString.lowercase(), 0, "Player wins cards".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong player wins cards message.")
                        position = checkOutput(outputString.lowercase(), position,
                            "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                            "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase())
                        if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
                        outputString = outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer").trim()
                    }
                }
            }

            position = if (numOfCardsOnTable == 0) checkOutput(outputString.lowercase(), 0, "No cards on the table".lowercase())
            else checkOutput(outputString.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output for number of cards or the top card.")
            if (whoWon == 0) {
                pointsPlayer += pointsOnTable
                numOfCardsPlayer += numOfCardsOnTable
            } else {
                pointsComputer += pointsOnTable
                numOfCardsComputer += numOfCardsOnTable
            }
            if (numOfCardsPlayer > numOfCardsComputer) pointsPlayer += 3
            else pointsComputer += 3
            position = checkOutput(outputString.lowercase(), position,
                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase(),
                "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong score output.")
            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun playFirstWrongInputTest(): CheckResult {
            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("Hello").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("me").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("0").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("play").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("yes").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            val topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            validOutput = checkPlayerOutput2(outputString, 6, 4, topCard)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.lowercase(), 0, "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong exit message.")

            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun wrongCardToPlayTest(): CheckResult {
            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("yes").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            val topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            validOutput = checkPlayerOutput2(outputString, 6, 4, topCard)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)

            outputString = main.execute("0").trim()
            position = checkOutput(outputString.lowercase(), 0, "Choose a card to play (1-6):".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output, after input an invalid card number.")

            outputString = main.execute("7").trim()
            position = checkOutput(outputString.lowercase(), 0, "Choose a card to play (1-6):".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output, after input an invalid card number.")

            outputString = main.execute("One").trim()
            position = checkOutput(outputString.lowercase(), 0, "Choose a card to play (1-6):".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output, after input an invalid card number.")


            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.lowercase(), 0, "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong exit message.")

            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

    }

    fun checkOutput(outputString: String, searchPos: Int, vararg checkStr: String): Int {
        var searchPosition = searchPos
        for (str in checkStr) {
            val findPosition = outputString.indexOf(str, searchPosition)
            if (findPosition == -1) return -1
            if ( outputString.substring(searchPosition until findPosition).isNotBlank() ) return -1
            searchPosition = findPosition + str.length
        }
        return searchPosition
    }

    fun checkOIfValidCards2(cardsStr: String, numOfCards: Int): Boolean {
        val cards = cardsStr.split(" ")
        val cardRegex = "(A|[2-9]|10|J|Q|K)(♦|♥|♠|♣)".toRegex()
        for (card in cards) if (!card.matches(cardRegex)) {
            return false
        }
        return cards.size == numOfCards
    }

    fun checkIfUniqueCards(outputString: String): Boolean {
        val lines = outputString.lines()
        val cards = lines.first().trim().split(" ")
        return cards.distinct().size == cards.size
    }

    fun checkOIfValidCardsInHand(cardsStr: String, numOfCards: Int): Boolean {
        val cards = cardsStr.split(" ")
        val cardRegex = "([1-6])\\)(A|[2-9]|10|J|Q|K)(♦|♥|♠|♣)".toRegex()
        for (card in cards) if (!card.matches(cardRegex)) {
            return false
        }
        return cards.size == numOfCards
    }

    fun checkInitial(output: String): ErrorData {
        val position = checkOutput(output.lowercase(), 0, "Initial cards on the table:".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong Initial cards message.")
        val cardsStr = output.substring(position).lines().map { it.trim() }.first { it != "" }
        if (cardsStr.isEmpty()) return ErrorData(false, "No initial cards are printed.")
        if ( !checkOIfValidCards2(cardsStr, 4) ) return ErrorData(false, "Invalid initial cards.")
        if ( !checkIfUniqueCards(cardsStr) ) return ErrorData(false, "Initial cards contain duplicate cards.")
        val cardsOnTable = cardsStr.trim().split(" ")
        val topCard = cardsOnTable.last()
        return ErrorData(true, "", topCard, cardsOnTable)
    }

    fun checkPlayerOutput2(output: String, numOfCards: Int, numOfCardsOnTable : Int, topCard: String): ErrorData {
        var position = if (numOfCardsOnTable == 0) checkOutput(output.lowercase(), 0, "No cards on the table".lowercase())
        else checkOutput(output.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Player turn: Wrong message for number of cards or the top card.")

        position = checkOutput(output.lowercase(), position, "Cards in hand:".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong cards in hand message.")
        var cardsInHand = output.substring(position).lines().map { it.trim() }.first { it != "" }
        if (!checkOIfValidCardsInHand(cardsInHand, numOfCards)) return ErrorData(false, "Wrong cards in hand message.")
        val listCardsInHand = cardsInHand.split(" ").map { it.substring(2) }
        var strCardsInHand = ""
        for (card in listCardsInHand) strCardsInHand += "$card "
        if ( !checkIfUniqueCards(strCardsInHand) ) return ErrorData(false, "Player's cards in hand contain duplicate cards.")
        val lastCard = listCardsInHand.last()
        position = output.indexOf(lastCard, position)
        position = checkOutput(output.lowercase(), position + lastCard.length, "Choose a card to play (1-$numOfCards):".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong prompt to choose a card.")
        return ErrorData(true, "", cardsList = listCardsInHand)
    }

    fun checkComputerOutput2(output: String, numOfCardsOnTable : Int, topCard: String): ErrorData {
        var position = if (numOfCardsOnTable == 0) checkOutput(output.lowercase(), 0, "No cards on the table".lowercase())
        else checkOutput(output.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Computer turn: Wrong output for number of cards or the top card.")

        position = checkOutput(output.lowercase(), position, "Computer plays".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong computer plays a card message.")

        val endIndex = output.indexOf("\n", position)
        if (endIndex < 0) return ErrorData(false, "Wrong output. Some lines are missing")
        val card = output.substring(position, endIndex).trim()
        if (!checkOIfValidCards2(card, 1)) return ErrorData(false, "Computer played an invalid card.")
        return ErrorData(true, "", card)
    }

    fun getRankSuit(card:String): Pair<String, String> {
        return if (card.length == 2) Pair(card.substring(0, 1), card.substring(1, 2))
        else Pair(card.substring(0, 2), card.substring(2, 3))
    }

    fun countPoints(cards: List<String>): Int {
        val ranks = listOf("A", "10", "J", "Q", "K")
        var count = 0
        for (card in cards) {
            val rank = if (card.length == 2) card.substring(0, 1)
            else card.substring(0, 2)
            if (rank in ranks) count++
        }
        return count
    }
  learner_created: false
- name: src/indigo/enums/MenuAction.kt
  visible: true
  text: |-
    package indigo.enums

    enum class MenuAction(val menuAction: String) {
        RESET("reset"),
        SHUFFLE("shuffle"),
        GET("get"),
        EXIT("exit");

        companion object {

            fun valueOfByMenuAction(menuAction: String): Boolean {
                return values()
                    .map { it.menuAction }
                    .any { it == menuAction }
            }
        }
    }
  learner_created: true
- name: src/indigo/player/Computer.kt
  visible: true
  text: |-
    package indigo.player

    import java.time.LocalDateTime
    import kotlin.random.Random
    import kotlin.random.nextInt

    class Computer : Player() {

        override fun handle(): String {
            val index = Random(LocalDateTime.now().nano).nextInt(cards.indices)
            val saveCard = cards[index]

            println("Computer plays $saveCard")
            cards = cards.toMutableList().apply { removeAt(index) }

            return saveCard
        }
    }
  learner_created: true
- name: src/indigo/handler/MenuPlayFirstHandler.kt
  visible: true
  text: |-
    package indigo.handler

    import indigo.Game
    import indigo.player.Computer
    import indigo.player.Gamer

    class MenuPlayFirstHandler(
        private val game: Game
    ) : MenuHandler {

        private val answerToPlayerHandler = hashMapOf("yes" to PlayerHandler(game, Gamer()), "no" to PlayerHandler(game, Computer()))

        override fun handler(cards: List<String>): List<String> {
            while(true) {
                println("Play first?")
                print("> ")
                val answer = readLine()!!

                if (answerToPlayerHandler.containsKey(answer.lowercase())) {
                    val secondPlayers = answerToPlayerHandler.filter { it.value != answerToPlayerHandler[answer]!! }

                    game.players = listOf(
                        answerToPlayerHandler[answer]!!,
                        secondPlayers.entries.first().value
                    )

                    break
                }
            }

            return cards
        }
    }
  learner_created: true
- name: src/indigo/Cards.kt
  visible: true
  text: |-
    package indigo

    object Cards {
        private val ranks = listOf("A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K")
        private val suits = listOf("♦", "♥", "♠", "♣")
        val cards = mutableListOf<String>().apply {
            for (i in suits.indices) {
                for (j in ranks.indices) {
                    add(String.format("%s%s", ranks[j], suits[i]))
                }
            }
        }
    }
  learner_created: true
- name: src/indigo/handler/MenuShuffleHandler.kt
  visible: true
  text: |-
    package indigo.handler

    class MenuShuffle : MenuHandler {

        override fun handler(cards: List<String>): List<String> {
            println("Card deck is shuffled.")
            return cards.shuffled()
        }
    }
  learner_created: true
- name: src/indigo/Game.kt
  visible: true
  text: |-
    package indigo

    import indigo.enums.MenuAction
    import indigo.handler.InitialCardHandler
    import indigo.handler.MenuExit
    import indigo.handler.MenuGet
    import indigo.handler.MenuHandler
    import indigo.handler.MenuPlayFirstHandler
    import indigo.handler.MenuReset
    import indigo.handler.MenuShuffle
    import indigo.handler.PlayerHandler

    class Game(
        var totalCards: List<String> = Cards.cards,
        var cardsOnTable: List<String> = mutableListOf(),
        var players: List<PlayerHandler> = mutableListOf()
    ) {

        fun start() {
            println("Indigo Card Game")
            totalCards = MenuPlayFirstHandler(this).handler(totalCards)
            totalCards = InitialCardHandler(this).handler(totalCards)

            while (true) {
    //            println("Choose an action (reset, shuffle, get, exit):")
    //            print("> ")
    //
    //            val action = readln()
    //            if (MenuAction.valueOfByMenuAction(action)) {
    //                totalCards = menuHandlers[MenuAction.valueOf(action.uppercase())]?.handler(totalCards)
    //                    ?: throw IllegalArgumentException("Error")
    //            } else {
    //                println("Wrong action.")
    //            }

                for (player in players) {
                    totalCards = player.handler(totalCards)
                }
            }
        }
    }
  learner_created: true
- name: src/indigo/handler/MenuResetHandler.kt
  visible: true
  text: |-
    package indigo.handler

    import indigo.Cards

    class MenuReset : MenuHandler {

        override fun handler(cards: List<String>): List<String> {
            println("Card deck is reset.")
            return Cards.cards
        }
    }
  learner_created: true
- name: src/indigo/enums/PlayerType.kt
  visible: true
  text: |-
    package indigo.enums

    enum class PlayerType {
        PLAYERS, COMPUTERS
    }
  learner_created: true
- name: src/indigo/handler/InitialCardHandler.kt
  visible: true
  text: |-
    package indigo.handler

    import indigo.Game

    class InitialCardHandler(
        private val game: Game
    ) : MenuHandler {

        override fun handler(cards: List<String>): List<String> {
            val topCards = mutableListOf<String>().apply {
                for (i in 0 until 4) {
                    add(cards[i])
                }
            }

            println("Initial cards on the table: ${topCards.joinToString(separator = " ")}")
            game.cardsOnTable = game.cardsOnTable.toMutableList().apply { addAll(topCards) }

            return cards.subList(4, cards.size)
        }
    }
  learner_created: true
- name: src/indigo/player/Player.kt
  visible: true
  text: |-
    package indigo.player

    import indigo.enums.MenuAction
    import indigo.handler.MenuExit
    import indigo.handler.MenuGet
    import indigo.handler.MenuHandler
    import indigo.handler.MenuReset
    import indigo.handler.MenuShuffle

    abstract class Player {
        companion object {
            private const val maxCard = 6
        }

        var cards: List<String> = mutableListOf()
        val menuHandlers: Map<MenuAction, MenuHandler> = mapOf(
            MenuAction.RESET to MenuReset(),
            MenuAction.SHUFFLE to MenuShuffle(),
            MenuAction.GET to MenuGet(),
            MenuAction.EXIT to MenuExit()
        )

        fun cardsInHand(): String {
            val cardsInHand = mutableListOf<String>().apply {
                for (i in cards.indices) {
                    add("${i + 1})${cards[i]}")
                }
            }

            return cardsInHand.joinToString(separator = " ")
        }

        fun takeCards(cards: List<String>): List<String> {
            if (this.cards.isEmpty() && cards.isNotEmpty()) {
                this.cards = cards.subList(0, maxCard)

                return cards.subList(maxCard, cards.size)
            }

            return cards
        }

        abstract fun handle(): String
    }
  learner_created: true
- name: src/indigo/handler/PlayerHandler.kt
  visible: true
  text: |-
    package indigo.handler

    import indigo.Game
    import indigo.player.Player

    class PlayerHandler(
        private val game: Game,
        private val player: Player
    ) : MenuHandler {

        override fun handler(cards: List<String>): List<String> {
            val nCard = player.takeCards(cards)

            println("\n${game.cardsOnTable.size} cards on the table, and the top card is ${game.cardsOnTable.last()}")
            if (game.totalCards.isEmpty() && player.cards.isEmpty()) {
                MenuExit().handler(cards)
            }

            game.cardsOnTable = game.cardsOnTable.toMutableList().apply { add(game.cardsOnTable.size, player.handle()) }

            return nCard
        }
    }
  learner_created: true
- name: src/indigo/handler/MenuExitHandler.kt
  visible: true
  text: |-
    package indigo.handler

    import kotlin.system.exitProcess

    class MenuExit : MenuHandler {

        override fun handler(cards: List<String>): List<String> {
            println("Game Over")
            exitProcess(0)
        }
    }
  learner_created: true
- name: src/indigo/player/Gamer.kt
  visible: true
  text: |-
    package indigo.player

    import indigo.enums.MenuAction

    class Gamer : Player() {

        override fun handle(): String {
            println("Cards in hand: ${cardsInHand()}")

            while (true) {
                println("Choose a card to play (1-${cards.size}):")
                print("> ")

                try {
                    val playerAction = readln()
                    if (MenuAction.valueOfByMenuAction(playerAction)) {
                        menuHandlers[MenuAction.valueOf(playerAction.uppercase())]?.handler(cards)
                        continue
                    }

                    val index = playerAction.toInt() - 1
                    val saveCard = cards[index]

                    cards = cards.toMutableList().apply { removeAt(index) }

                    return saveCard
                } catch (e: Exception) {
                    continue
                }
            }
        }
    }
  learner_created: true
- name: src/indigo/handler/MenuGetHandler.kt
  visible: true
  text: |-
    package indigo.handler

    import indigo.Cards

    class MenuGet : MenuHandler {

        override fun handler(cards: List<String>): List<String> {
            println("Number of cards:")
            print("> ")

            try {
                val number = readln().toInt()
                if (number !in 1..Cards.cards.size) {
                    println("Invalid number of cards.")
                    return cards
                }

                if (number > cards.size) {
                    println("The remaining cards are insufficient to meet the request.")
                    return cards
                }

                println(cards.subList(0, number).joinToString(separator = " "))
                return cards.subList(number, cards.size)
            } catch (ex: Exception) {
                println("Invalid number of cards.")
                return cards
            }
        }
    }
  learner_created: true
- name: src/indigo/handler/MenuHandler.kt
  visible: true
  text: |-
    package indigo.handler

    interface MenuHandler {

        fun handler(cards: List<String>): List<String>
    }
  learner_created: true
- name: src/indigo/ScoreService.kt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16511#comment
status: Solved
feedback:
  message: Congratulations!
  time: Fri, 08 Apr 2022 16:53:07 UTC
record: 4
